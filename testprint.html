<html>

<head>
    <title>Printer Tool</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-dark-5@1.1.3/dist/css/bootstrap-dark-plugin.min.css"
        rel="stylesheet">
    <meta name="theme-color" content="#111111" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#eeeeee" media="(prefers-color-scheme: dark)">
</head>
<body>
    <div class="container-fluid">
        <div class="row" style="padding-top: 16px;">
            <div class="col-3">
                <div class="d-grid gap-2 col-8 mx-auto mb-3">
                    <button class="btn btn-primary" id="addprinter">âž• Add Printer</button>
                </div>
                <ol id="printerlist" class="list-group list-group-numbered">
                </ol>
            </div>
            <div class="col-9">
                <form id="labelForm" action="javascript:void(0);">
                    <div class="col row mb-3">
                        <label for="leftOffset" class="col-sm-2 col-form-label">Left Margin</label>
                        <div class="col-sm-2">
                            <input class="form-control" type="number" id="leftOffset" value="10" name="leftOffset">
                        </div>
                        <label for="modalFont" class="col-sm-1 offset-sm-1 col-form-label">Font</label>
                        <div class="col-sm-2">
                            <select id="modalFont" class="form-select" aria-label="Font selection" name="fontSize">
                                <option>1</option>
                                <option>2</option>
                                <option>3</option>
                                <option>4</option>
                                <option selected value="5">5 (allcaps)</option>
                                <!-- <option value="6">6 (numbers</option>
                                <option value="7">7 (numbers)</option> -->
                            </select>
                        </div>
                        <label for="labelColor" class="col-sm-2 col-form-label">Label Color</label>
                        <div class="col-sm-1">
                            <input id="labelColor" type="color" class="form-control col-sm-1 form-control-color"
                                value="#FFFFFF" name="labelColor" title="Choose paper color" style="height: 2.5rem;">
                        </div>
                    </div>
                    <div class="col row mb-3">
                        <label for="lineSpacing" class="col-sm-2 col-form-label">Line spacing</label>
                        <div class="col-sm-2">
                            <input class="form-control" type="number" id="lineSpacing" value="5" name="lineSpacing">
                        </div>
                    </div>
                    <textarea id="labelFormText" name="labelText" maxlength="25" cols="25" rows="25" wrap="hard"
                        style="resize: none; font-family: monospace; font-size: 18px; overflow-y: hidden; overflow-x: hidden;"
                        placeholder="Enter your label text here!"></textarea>
                </form>
            </div>
        </div>
    </div>
    <div id="printerOptionModal" class="modal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <form id="printerSettingsForm">
                    <div class="modal-header">
                        <h5 class="modal-title">Label Settings</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <label for="modalPrinterIndex" class="form-label">Printer ID</label>
                        <div class="input-group mb-3">
                            <span id="modalPrinterIndexText" class="input-group-text">42Q424242424</span>
                            <input id="modalPrinterIndex" class="form-control" type="text" value="-1"
                                aria-label="Printer ID" aria-describedby="modalPrinterIndexText" disabled readonly>
                        </div>
                        <div class="mb-3">
                            <div class="row">
                                <div class="col">
                                    <label for="modalLabelWidth" class="form-label">Label Width</label>
                                    <div class="input-group mb-3">
                                        <input id="modalLabelWidth" type="text" class="form-control" placeholder="2.25"
                                            aria-label="Width" required pattern="\d+\.*\d*">
                                        <span id="modalLabelWidthText" class="input-group-text">in</span>
                                    </div>
                                </div>
                                <div class="col">
                                    <label for="modalLabelHeight" class="form-label">Label Height</label>
                                    <div class="input-group mb-3">
                                        <input id="modalLabelHeight" type="text" class="form-control" placeholder="1.25"
                                            aria-label="Height" required pattern="\d+\.*\d*">
                                        <span id="modalLabelHeightText" class="input-group-text">in</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="row">
                                <div class="col row mb-3">
                                    <label for="modalDarkness" class="col-sm-6 col-form-label">Darkness</label>
                                    <div class="col-sm-6">
                                        <div class="col-sm-7">
                                            <select id="modalDarkness" class="form-select" aria-label="Darkness">
                                                <option>1</option>
                                                <option>2</option>
                                                <option>3</option>
                                                <option>4</option>
                                                <option>5</option>
                                                <option>6</option>
                                                <option>7</option>
                                                <option>8</option>
                                                <option>9</option>
                                                <option>10</option>
                                                <option>11</option>
                                                <option>12</option>
                                                <option>13</option>
                                                <option>14</option>
                                                <option>15</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div class="col row mb-3">
                                    <label for="modalSpeed" class="col-sm-5 col-form-label">Speed</label>
                                    <div class="col-sm-7">
                                        <select id="modalSpeed" class="form-select" aria-label="Speed">
                                            <option>1</option>
                                            <option>2</option>
                                            <option>3</option>
                                            <option>4</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <input id="modalSubmit" type="submit" class="btn btn-primary" value="Save">
                    </div>
                </form>
            </div>
        </div>
    </div>
    <script>
        // idb keyval wrapper
        // https://github.com/jakearchibald/idb-keyval
        function _typeof(n) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (n) { return typeof n } : function (n) { return n && "function" == typeof Symbol && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n })(n) } !function (n, t) { "object" === ("undefined" == typeof exports ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((n = "undefined" != typeof globalThis ? globalThis : n || self).idbKeyval = {}) }(this, (function (n) { "use strict"; function t(n) { return new Promise((function (t, e) { n.oncomplete = n.onsuccess = function () { return t(n.result) }, n.onabort = n.onerror = function () { return e(n.error) } })) } function e(n, e) { var r, o = (!navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise((function (n) { var t = function () { return indexedDB.databases().finally(n) }; r = setInterval(t, 100), t() })).finally((function () { return clearInterval(r) })) : Promise.resolve()).then((function () { var r = indexedDB.open(n); return r.onupgradeneeded = function () { return r.result.createObjectStore(e) }, t(r) })); return function (n, t) { return o.then((function (r) { return t(r.transaction(e, n).objectStore(e)) })) } } var r; function o() { return r || (r = e("keyval-store", "keyval")), r } function u(n, e) { return n("readonly", (function (n) { return n.openCursor().onsuccess = function () { this.result && (e(this.result), this.result.continue()) }, t(n.transaction) })) } n.clear = function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o(); return n("readwrite", (function (n) { return n.clear(), t(n.transaction) })) }, n.createStore = e, n.del = function (n) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o(); return e("readwrite", (function (e) { return e.delete(n), t(e.transaction) })) }, n.delMany = function (n) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o(); return e("readwrite", (function (e) { return n.forEach((function (n) { return e.delete(n) })), t(e.transaction) })) }, n.entries = function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o(), t = []; return u(n, (function (n) { return t.push([n.key, n.value]) })).then((function () { return t })) }, n.get = function (n) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o(); return e("readonly", (function (e) { return t(e.get(n)) })) }, n.getMany = function (n) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o(); return e("readonly", (function (e) { return Promise.all(n.map((function (n) { return t(e.get(n)) }))) })) }, n.keys = function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o(), t = []; return u(n, (function (n) { return t.push(n.key) })).then((function () { return t })) }, n.promisifyRequest = t, n.set = function (n, e) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o(); return r("readwrite", (function (r) { return r.put(e, n), t(r.transaction) })) }, n.setMany = function (n) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o(); return e("readwrite", (function (e) { return n.forEach((function (n) { return e.put(n[1], n[0]) })), t(e.transaction) })) }, n.update = function (n, e) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o(); return r("readwrite", (function (r) { return new Promise((function (o, u) { r.get(n).onsuccess = function () { try { r.put(e(this.result), n), o(t(r.transaction)) } catch (n) { u(n) } } })) })) }, n.values = function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o(), t = []; return u(n, (function (n) { return t.push(n.value) })).then((function () { return t })) }, Object.defineProperty(n, "__esModule", { value: !0 }) }));

        class PrinterManager {
            #devices = [];
            #printers = [];

            #printerType;
            #activePrinter = 0;

            constructor(printerType, btnContainer, labelForm, addPrinterBtn, configModal) {
                this.#printerType = printerType;

                this.btnContainer = btnContainer;
                this.labelForm = labelForm;
                this.labelTextarea = this.labelForm.querySelector('textarea');
                this.labelTextarea.addEventListener('keyup', () => this.#limitTextArea());
                this.labelTextarea.addEventListener('change', () => this.#limitTextArea());
                this.labelForm.querySelector('#leftOffset').addEventListener('change', () => this.#resizeTextArea());
                this.labelForm.querySelector('#leftOffset').addEventListener('keyup', () => this.#resizeTextArea());
                this.labelForm.querySelector('#lineSpacing').addEventListener('change', () => this.#resizeTextArea());
                this.labelForm.querySelector('#lineSpacing').addEventListener('keyup', () => this.#resizeTextArea());
                this.labelForm.querySelector('#modalFont').addEventListener('change', () => this.#resizeTextArea());
                this.labelForm.querySelector('#labelColor').addEventListener('change', () => this.#setLabelColor());

                this.addPrinterBtn = addPrinterBtn;
                addPrinterBtn.addEventListener('click', async (e) => this.printerPair(e));

                this.configModal = configModal;
                this.configModalHandle = new bootstrap.Modal(this.configModal);
                this.configModal.querySelector('form').addEventListener('submit', async (e) => await this.updatePrinterConfig(e));

                navigator.usb.addEventListener('connect', async (e) => this.printerConnect(e));
                navigator.usb.addEventListener('disconnect', async (e) => this.printerDisconnect(e));
            }

            get printers() { return this.#printers; }

            get activePrinter() { return this.#activePrinter; }
            set activePrinter(value) {
                this.#activePrinter = value;
                const p = this.#printers[this.#activePrinter];
                if (p) {
                    this.labelForm.querySelector('#labelColor').value = p.labelColor;
                }
                this.#resizeTextArea();
            }

            async printForm(printerId) {
                let form = new FormData(this.labelForm);
                let rawText = form.get('labelText').replaceAll("\r", "");
                let fontSize = parseInt(form.get('fontSize'));
                let xOffset = parseInt(form.get('leftOffset'));
                let printer = this.#printers[printerId];

                printer.begin().setOffset(xOffset, 0).setFont(fontSize);
                rawText.split("\n").forEach(l => printer.addText(l));
                printer.end();
                await printer.print();
            }

            async printerConnect(e) {
                if (!this.#devices.includes(e.device)) {
                    this.#devices.push(e.device);
                    let printer = new this.#printerType(e.device);
                    await printer.connect();
                    this.#printers.push(printer);
                }

                this.resetPrinterButtons();
                this.#resizeTextArea();
            }

            async printerDisconnect(e) {
                const idx = this.#devices.findIndex(i => e.device == i);
                if (idx > -1) {
                    const p = this.#printers[idx];
                    this.#devices.splice(idx, 1);
                    this.#printers.splice(idx, 1);
                    this.resetPrinterButtons();
                    await p.dispose();
                }
            }

            async printerPair(e) {
                try {
                    let device = await navigator.usb.requestDevice({
                        filters: [
                            { vendorId: this.#printerType.usbVendorId }
                        ]
                    });

                    await this.printerConnect( { device : device} )
                } catch (e) {
                    console.log("Failed to connect to printer!");
                    console.log(e);
                    return;
                }
            }

            async printerReloadAll() {
                this.#devices = [];
                this.#printers.forEach(p => p.dispose());
                this.#printers = [];

                navigator.usb.getDevices().then((printers) => {
                    printers.forEach(async d => {
                        await this.printerConnect( { device : d });
                    });

                    this.resetPrinterButtons();
                    this.activePrinter = 0;
                    this.#resizeTextArea();
                });
            }

            #limitTextArea() {
                const maxLines = this.labelTextarea.rows;
                var currentLinesRendered = (new FormData(this.labelForm)).get('labelText').split('\n');

                while (currentLinesRendered.length > maxLines) {
                    this.labelTextarea.value = this.labelTextarea.value.slice(0, -1);
                    currentLinesRendered = (new FormData(this.labelForm)).get('labelText').split('\n');
                }

                // if ((currentLines.length >= maxLines) || (currentLinesRendered >= maxLines)) {
                //     let lines = currentLines.slice(0, maxLines);
                //     this.labelTextarea.value = lines.join('\n');
                // }
            }

            #resizeTextArea() {
                let p = this.#printers[this.activePrinter];
                if (!p) {
                    return;
                }

                let form = new FormData(this.labelForm);
                let fontSize = parseInt(form.get('fontSize'));
                let xOffset = parseInt(form.get('leftOffset'));
                let lineSpacing = parseInt(form.get('lineSpacing'));
                xOffset = xOffset >= p.labelWidthDots ? p.labelWidthDots - 1 : xOffset;

                let font = p.fontSizes[fontSize];
                // Columns in Chrome render a little funny so we subtract one
                // to match the true print width, more or less.
                let cols = Math.floor((p.labelWidthDots - xOffset) / font.x) - 1;
                cols = cols < 1 ? 1 : cols;
                let rows = Math.floor(p.labelHeightDots / (font.y + lineSpacing));
                rows = rows < 1 ? 1 : rows;

                p.lineSpacing = lineSpacing;

                this.labelTextarea.cols = cols;
                this.labelTextarea.rows = rows;
                this.labelTextarea.maxLength = rows * cols;

                this.#limitTextArea();
            }

            #setLabelColor() {
                const p = this.#printers[this.activePrinter];
                let form = new FormData(this.labelForm);
                p.labelColor = form.get('labelColor');
                this.#drawPrinterButtonHighlights();
            }

            resetPrinterButtons() {
                this.btnContainer.innerHTML = "";
                this.#printers.forEach((printer, index) => this.#drawPrinterButton(printer, index));
            }

            showConfigModal(printer, index) {
                this.configModal.querySelector('#modalPrinterIndex').value = index;
                this.configModal.querySelector('#modalPrinterIndexText').textContent = printer.serial;
                this.configModal.querySelector('#modalLabelWidth').value = printer.labelWidth;
                this.configModal.querySelector('#modalLabelHeight').value = printer.labelHeight;
                this.configModal.querySelector('#modalDarkness').value = printer.density;
                this.configModal.querySelector('#modalSpeed').value = printer.speed;
                this.configModalHandle.show();
            }

            async updatePrinterConfig(e) {
                e.preventDefault();
                const form = this.configModal.querySelector("form").elements;
                let deviceId = form.modalPrinterIndex.value;
                let printer = this.#printers[deviceId];

                printer.labelWidth = (parseFloat(form.modalLabelWidth.value));
                printer.labelHeight = (parseFloat(form.modalLabelHeight.value));
                this.configModalHandle.hide();

                await printer.configDensity(form.modalDarkness.value);
                await printer.configSpeed(form.modalSpeed.value);
                await printer.configLabelWidth();

                this.activePrinter = deviceId;
                this.resetPrinterButtons();
            }

            #drawPrinterButtonHighlights() {
                this.#printers.forEach((printer, index) => {
                    let element = document.getElementById(`printer_${index}`);
                    let highlight = this.#activePrinter == index ? "var(--bs-blue)" : "transparent";
                    element.style.background = `linear-gradient(to right, ${highlight}, ${highlight}, ${printer.labelColor}, ${printer.labelColor})`;
                });
            }

            #drawPrinterButton(printer, index) {
                let highlight = this.#activePrinter == index ? "var(--bs-blue)" : "transparent";
                let element = document.createElement("div");
                element.innerHTML = `
    <li id="printer_${index}" data-device-id="${index}"
        class="list-group-item d-flex flex-row justify-content-between sligh-items-start"
        style="background: linear-gradient(to right, ${highlight}, ${highlight}, ${printer.labelColor}, ${printer.labelColor});">
        <div class="col-sm-8">
            <div class="col-sm-12">
                <span data-serial="${printer.serial}">${printer.serial}</span>
            </div>
            <div class="col-sm-12">
                <span>${printer.labelWidth}" x ${printer.labelHeight}"</span>
            </div>
        </div>
        <div class="d-flex flex-row justify-content-end">
            <div class="btn-group" role="group" aria-label="Printer button group">
                <button id="printto_${index}" class="btn btn-success btn-lg" data-label-width="${printer.labelWidth}" data-label-height="${printer.labelHeight}" data-device-id="${index}">ðŸ–¨</button>
                    <button class="btn btn-success dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" aria-expanded="false">
                        <span class="visually-hidden">Settings</span>
                    </button>
                    <ul class="dropdown-menu">
                        <li><a id="printtest_${index}" data-device-id="${index}" class="dropdown-item" href="#">
                            Print test page
                        </a></li>
                        <li><a id="autosense_${index}" data-device-id="${index}" class="dropdown-item" href="#">
                            AutoSense length
                        </a></li>
                        <li><a id="configprinter_${index}" data-device-id="${index}" class="dropdown-item" href="#">
                            Set label config
                        </a></li>
                    </ul>
                </div>
            </div>
        </div>
    </li>`;
                this.btnContainer.appendChild(element);

                document.getElementById(`printer_${index}`)
                    .addEventListener('click', async (e) => {
                        e.preventDefault();
                        let deviceId = e.currentTarget.dataset.deviceId;
                        this.activePrinter = deviceId;
                        this.#drawPrinterButtonHighlights();
                    });

                document.getElementById(`configprinter_${index}`)
                    .addEventListener('click', async (e) => {
                        e.preventDefault();
                        let deviceId = e.target.dataset.deviceId;
                        this.showConfigModal(this.#printers[deviceId], deviceId);
                    });

                document.getElementById(`printto_${index}`)
                    .addEventListener('click', async (e) => {
                        e.preventDefault();
                        let deviceId = e.target.dataset.deviceId;
                        this.printForm(deviceId);
                    });

                document.getElementById(`autosense_${index}`)
                    .addEventListener('click', async (e) => {
                        e.preventDefault();
                        let deviceId = e.target.dataset.deviceId;
                        await this.#printers[deviceId].configLabelWidth();
                        await this.#printers[deviceId].setLabelHeightCalibration();
                    });

                document.getElementById(`printtest_${index}`)
                    .addEventListener('click', async (e) => {
                        e.preventDefault();
                        let deviceId = e.target.dataset.deviceId;
                        await this.#printers[deviceId].printTestPage();
                    });
            }
        }

        class LineBreakTransformer {
            #container = '';

            transform(chunk, controller) {
                this.#container += chunk;
                const lines = this.#container.split('\n');
                this.#container = lines.pop();
                lines.forEach(line => controller.enqueue(line));
            }

            flush(controller) {
                controller.enqueue(this.#container);
            }
        }

        class lp2844 {
            #cmdBuffer = "";
            #inputStream;
            #nextLineCache;
            #device;
            #deviceOut;
            #deviceIn;
            #serialNumber;
            #modelNumber;
            #firmware;
            #doubleBuffering;

            #fontNumber = "1";
            #speed = 4;
            #density = 8;

            // LP 2844 has a 203 DPI print head
            #dpi = 203;

            #labelWidthIn;
            #xLabel;
            #labelHeightIn;
            #yLabel;
            #labelGapIn;
            #gLabel;

            // Temp holders on a per-label basis.
            #xOffset = 0;
            #yOffset = 0;

            /**
             * Create a new instance of the LP2844 class.
             *
             * @param device - The WebUSB device object representing the printer.
             * @param (int) lineSpacing - Additional dots to place between lines.
             * @param (float) labelDimensionRoundingStep - The nearest fraction of an inch to round label dimensions to.
             */
            constructor(device, lineSpacing, labelDimensionRoundingStep) {
                this.#device = device; // The USB device to work with

                this.labelColor = "#FFFFFF" // Handy to store, not actually used anywhere

                // Additional spacing between lines of text, in dots.
                this.lineSpacing = lineSpacing || 0;

                // Debug flag for dumping commands to the console before sending
                // to the printer
                this.debug = true;

                // The value to round read-from-config label sizes to.
                // Configuration values can often be slightly off from the
                // human-readable value, so this normalizes them.
                // Most labels come in 0.25" increments, if your labels are a different
                // fraction then set the appropriate rounding fraction.
                this.labelDimensionRoundingStep = labelDimensionRoundingStep || 0.25;
            }

            // LP 2844 and variants use this USB vendor ID
            static get usbVendorId() { return 0x0a5f; }

            // LP 2844 print heads are 203 DPI.
            get dpi() { return this.#dpi; }

            get serial() { return this.#serialNumber; }
            get firmware() { return this.#firmware; }
            get modelId() { return this.#modelNumber; }

            get commandBuffer() { return this.#cmdBuffer; }

            get fontSizes() {
                return {
                    // Each character has 2 dots of inter-character space added
                    // between each character and one dot added for vertical
                    "1": { "y": 10, "x": 10 },
                    "2": { "y": 14, "x": 12 },
                    "3": { "y": 16, "x": 14 },
                    "4": { "y": 20, "x": 16.2 },
                    "5": { "y": 48, "x": 36 },
                    "6": { "y": 19, "x": 16 },
                    "7": { "y": 19, "x": 16 },
                };
            };

            get labelWidth() { return this.#labelWidthIn; }
            set labelWidth(value) {
                this.#labelWidthIn = value;
                this.#xLabel = Math.trunc(value * this.#dpi);
            }
            get labelWidthDots() { return this.#xLabel; }

            get labelHeight() { return this.#labelHeightIn; }
            set labelHeight(value) {
                this.#labelHeightIn = value;
                this.#yLabel = Math.trunc(value * this.#dpi);
            }
            get labelHeightDots() { return this.#yLabel; }

            get fontSize() { return this.#fontNumber; }
            get speed() { return this.#speed; }
            get density() { return this.#density; }

            /**
             * Begin a new label. Must be called to start a new label.
             */
            begin() {
                return this.addCmd("\nN");
            }

            /**
             * Complete a label. Must be called to print the label.
             *
             * @param (int) count - The number of labels to print, 1 or higher.
             */
            end(count) {
                count = Math.trunc(count) || 1;
                count = (count < 1) ? 1 : count;

                return this.addCmd(`P${count}`);
            }

            /**
             * Run the commands in the command buffer against the printer, clearing the buffer.
             */
            async print() {
                console.debug("Sending print command to printer..");
                if (this.debug) {
                    console.debug(this.#cmdBuffer);
                }
                try {
                    const buffer = (new TextEncoder()).encode(this.#cmdBuffer);
                    await this.#device.transferOut(this.#deviceOut.endpointNumber, buffer);
                    console.debug("Completed sending print command.");
                } catch (e) {
                    console.error(`Print error: ${e.name}: ${e.message}`);
                } finally {
                    this.clearCommandBuffer();
                    this.clearOffsets();
                }
            }

            /**
             * Set up the printer connection. Must be done before calling any
             * other methods.
             */
            async connect(debugByLoggingPrinterToConsole) {
                const d = this.#device;

                // Each printer will have one input and one output interface
                // Go find them.
                let o, i;
                for (let endpoint of d.configuration.interfaces[0].alternates[0].endpoints) {
                    if (endpoint.direction == 'out') {
                        o = endpoint;
                    } else if (endpoint.direction == 'in') {
                        i = endpoint;
                    }
                }

                if (!o || !i) {
                    console.error("Failed to connect input or output to printer!");
                }

                this.#deviceOut = o;
                this.#deviceIn = i;

                // And wire 'em up!
                await d.open();
                await d.selectConfiguration(1);
                await d.claimInterface(0);

                this.#inputStream = new ReadableStream({
                    pull: async (controller) => {
                        const result = await this.#device.transferIn(this.#deviceIn.endpointNumber, 64);
                        const chunk = new Uint8Array(result.data.buffer, result.data.byteOffset, result.data.byteLength);
                        controller.enqueue(chunk);
                    },
                }).pipeThrough(new TextDecoderStream())
                  .pipeThrough(new TransformStream(new LineBreakTransformer()));

                // Test the connection by pulling the current configuration.
                await this.configGetFromPrinter();

                if (debugByLoggingPrinterToConsole) {
                    // Whatever messages arrive will be dumped straight to the
                    // console. Note that this eats up the incoming data so
                    // other listening commands won't work while this is active.
                    this.#listenForDataAndConsoleLogAlways();
                }
            }

            /**
             * Get the current configuration from the printer, overwriting any
             * uncommitted configuration changes.
             */
            async configGetFromPrinter() {
                var config;
                var validConfig = false;
                var retryLimit = 3;
                do {
                    retryLimit--;

                    // Start listening for the response we're about to generate
                    let listenResult = this.#listenForData();

                    await this.begin().addCmd("UQ").print();

                    let rawText = await listenResult;
                    config = this.#parseConfigInquiry(rawText);

                    if (this.debug) {
                        console.debug(config);
                    }

                    // All firmwares return these values, if they failed to parse
                    // out for any reason it means we got an error reading the
                    // config and we should try again.
                    validConfig = config.hasOwnProperty("labelWidthDots") &&
                        config.hasOwnProperty("firmware") &&
                        config.hasOwnProperty("speed");
                } while (!validConfig && retryLimit > 0)

                this.#density = config.density;
                this.#doubleBuffering = config.doubleBuffering;
                this.#speed = config.speed;
                this.#serialNumber = config.serial;
                this.#firmware = config.firmware;
                this.#gLabel = config.labelGapDots;

                let rawX = config.labelWidthDots / this.#dpi;
                let rawY = config.labelHeightDots / this.#dpi;
                let inverse = 1.0 / this.labelDimensionRoundingStep

                this.labelWidth = Math.round(rawX * inverse) / inverse;
                this.labelHeight = Math.round(rawY * inverse) / inverse;
            }

            #parseConfigInquiry(rawText) {
                const lines = rawText
                    .replaceAll('\r', '')
                    .split('\n')
                    .filter(i => i);

                // UKQ1935HLU     V4.29    # ID code and firmware version
                // First line determines firmware version to read and is consistent
                // across observed dumps.
                const header = lines[0].split(' ').filter(i => i);
                // First element is always the model ID
                const modelId = header[0];
                // Header may include "FDX", indicating a nonstandard unit.
                // We ignore this and jump to the last element, which will be
                // the firmware version
                const firmware = header[header.length - 1];

                let result = {
                    model: modelId,
                    firmware: firmware,
                    serial: "no_serial"
                };

                // All the rest of these follow some kind of standard pattern for
                // each value which we can pick up with regex. The cases here are
                // built out of observed configuration dumps.
                for (let i = 1; i < lines.length; i++) {
                    let str = lines[i]
                    switch (true) {
                        case /^S\/N.*/.test(str):
                            // S/N: 42A000000000       # Serial number
                            result.serial = str.substring(5).trim();
                            break;
                        case /^Serial\sport/.test(str):
                            // Serial port:96,N,8,1    # Serial port config
                            result.serialPort = str.substring(12).trim();
                            break;
                        case /^q\d+\sQ/.test(str):
                            // q600 Q208,25            # Form width (q) and length (Q). See those commands.
                            let settingsForm = str.trim().split(' ');
                            let length = settingsForm[1].split(',');
                            result.labelWidthDots = parseInt(settingsForm[0].substring(1));
                            result.labelHeightDots = parseInt(length[0].substring(1));
                            result.labelGapDots = parseInt(length[1].trim());
                            break;
                        case /^S\d\sD\d\d\sR/.test(str):
                            // S4 D08 R112,000 ZB UN   # Config settings 2
                            let settings2 = str.trim().split(' ');
                            let ref = settings2[2].split(',');
                            result.speed = parseInt(settings2[0].substring(1));
                            result.density = parseInt(settings2[1].substring(1));
                            result.xRef = parseInt(ref[0].substring(1));
                            result.yRef = parseInt(ref[1]);
                            break;
                        case /^I\d,.,\d\d\d\sr[YN]/.test(str):
                            // I8,A,001 rY JF WY       # Config settings 1
                            let settings1 = str.split(' ');
                            result.doubleBuffering = settings1[1][1] === 'Y'
                            break;
                        case /^HEAD\s\s\s\susage\s=/.test(str):
                            // HEAD    usage =     249,392"    # Odometer of the head
                            let headsplit = str.substring(15).split(' ');
                            result.headDistanceIn = headsplit[headsplit.length - 1];
                            break;
                        case /^PRINTER\susage\s=/.test(str):
                            // PRINTER usage =     249,392"    # Odometer of the printer
                            let printsplit = str.substring(15).split(' ');
                            result.printerDistanceIn = printsplit[printsplit.length - 1];
                            break;
                        case /^\d\d\s\d\d\s\d\d\s$/.test(str):
                            // 06 10 14                # AutoSense settings, see below
                        case /^oE.,/.test(str):
                            // oEv,w,x,y,z             # Config settings 4, see below
                        case /^Option:/.test(str):
                            // Option:D,Ff             # Config settings 3, see below
                        case /^Emem:/.test(str):
                            // Emem:031K,0037K avl     # Soft font storage
                        case /^Gmem:/.test(str):
                            // Gmem:000K,0037K avl     # Graphics storage
                        case /^Fmem:/.test(str):
                            // Fmem:000.0K,060.9K avl  # Form storage
                        case /^Emem used:/.test(str):
                            // Emem used: 0     # Soft font storage
                        case /^Gmem used:/.test(str):
                            // Gmem used: 0            # Graphics storage
                        case /^Fmem used:/.test(str):
                            // Fmem used: 0 (bytes)    # Form storage
                        case /^Available:/.test(str):
                            // Available: 130559       # Total memory for Forms, Fonts, or Graphics
                        case /^Cover:/.test(str):
                            // Cover: T=118, C=129     # (T)reshold and (C)urrent Head Up (open) sensor.
                        case /^Image buffer size:/.test(str):
                            // Image buffer size:0245K # Image buffer size in use
                        case /^Page\sMode/.test(str):
                            // Page mode               # Printer is in page mode
                            // These are status details and are uninteresting, so we skip them.
                            break;
                        default:
                            console.log("Unhandled config line '" + str + "', consider reporting a bug!");
                            break;
                    }
                }

                return result;
            }

            async #nextLine() {
                if (this.#nextLineCache) {
                    const line = this.#nextLineCache;
                    this.#nextLineCache = null;
                    return line;
                }

                let timedOut = false;
                const nextLinePromise = (async () => {
                    const reader = this.#inputStream.getReader();
                    const { value, done } = await reader.read();
                    reader.releaseLock();

                    if (done) {
                        return;
                    }

                    if (timedOut) {
                        this.#nextLineCache = value;
                        return;
                    }

                    return value;
                })();

                const timeoutPromise = new Promise((resolve) => {
                    setTimeout(() => {
                        timedOut = true;
                        resolve();
                    }, 200);
                });

                return Promise.race([nextLinePromise, timeoutPromise]);
            }

            async #listenForDataAndConsoleLogAlways() {
                while (true) {
                    const line = await this.#nextLine();
                    console.log("PRINTER SAYS TEXT IN SINGLE QUOTES\n'" + line + "'");
                }
            }

            async #listenForData() {
                let aggregate = "";
                while (true) {
                    const line = await this.#nextLine();
                    if (line === undefined) {
                        return aggregate;
                    }
                    aggregate += line + '\n';
                }
            }

            /**
             * Disconnect from the printer. Further commands will fail. Create a
             * new instance instead of trying to re-use this one after disposal.
             */
            async dispose() {
                await this.#device.close();
            }

            /**
             * Draw a test pattern that looks like
             * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
             * â–ˆâ–ˆâ–ˆ
             *    â–ˆâ–ˆâ–ˆ
             *       â–ˆâ–ˆâ–ˆ
             *          â–ˆâ–ˆâ–ˆ
             * ////////////
             */
            async printTestPage() {
                await this.configLabelWidth();

                let quarter = (this.labelWidthDots / 4);
                let lineHeight = 20;

                this.begin()
                    .setOffset(0, lineHeight)
                    .addLine(this.labelWidthDots, 20)
                    .setOffset(0, lineHeight * 2)
                    .addLine(quarter, 20)
                    .setOffset(quarter, lineHeight * 3)
                    .addLine(quarter, 20)
                    .setOffset(quarter * 2, lineHeight * 4)
                    .addLine(quarter, 20)
                    .setOffset(quarter * 3, lineHeight * 5)
                    .addLine(quarter, 20)
                    .setOffset(0, lineHeight * 6);

                let slashStart = (lineHeight * 6) + 5;
                let slashHeight = 12;
                for (let i = 0; i <= this.labelWidthDots; i += 4) {
                    this.setOffset(i + 0, slashStart + 0)
                        .addLine(1, slashHeight)
                        .setOffset(i + 1, slashStart + slashHeight)
                        .addLine(1, slashHeight)
                        .setOffset(i + 2, slashStart + (slashHeight * 2))
                        .addLine(1, slashHeight)
                        .setOffset(i + 3, slashStart + (slashHeight * 3))
                        .addLine(1, slashHeight)
                }
                this.end();
                await this.print();
            }

            setFont(fontNumber) {
                fontNumber = Math.trunc(fontNumber) || 1;

                if (fontNumber < 1 || fontNumber > 7) {
                    console.log("Invalid font size! Defaulting to 1");
                    this.#fontNumber = 1;
                    return;
                }

                this.#fontNumber = fontNumber;
                return this;
            }

            setOffset(x, y) {
                this.#xOffset = Math.trunc(x) || 0;

                if (y !== undefined) {
                    this.#yOffset = Math.trunc(y) || 0;
                }
                return this;
            }

            /**
             * Send the configured label width to the printer
             */
            async configLabelWidth() {
                await this.begin().addCmd("q" + this.#xLabel).print();
            }

            /**
             * Perform an autocalibration for the label length
             */
            async setLabelHeightCalibration() {
                await this.begin().addCmd("xa").print();
            }

            /**
             * Configure the density (darkness) of the print.
             *
             * @param (int) density - 0 (light) through 15 (dark) print density.
             */
            async configDensity(density) {
                density = parseInt(density) || 8;
                density = (density < 0 || density > 15) ? 8 : density;

                await this.begin().addCmd("D" + density).print();
            }

            /**
             * Reset the printer, same as turning it off and on.
             */
            async configReset(){
                await this.begin().addCmd("^@").print();
            }

            /**
             * Configure the speed of the print.
             *
             * @param (int) speed - 1 (slow) to 4 (fast) print speed.
             */
            async configSpeed(speed) {
                speed = parseInt(speed) || 4;
                speed = (speed < 1 || speed > 4) ? 4 : speed;

                await this.begin().addCmd("S" + speed).print();
            }

            /**
             * Add text, advancing the yOffset by the font height + line spacing.
             *
             * @param (string) text - The text to add
             * @param (int) size - The size to scale the font, 1-6
             *
             * @example
             *     addText("Hello world!", 1)
             */
            addText(text, size) {
                text = text || "";
                size = Math.trunc(size) || 1;

                // Font size 5 only supports uppercase letters.
                if (this.fontSize == 5) {
                    text = text.toUpperCase();
                }

                this.#addTextRaw(this.#xOffset, this.#yOffset, 0, this.#fontNumber, size, size, false, text);

                let textHeight = (size * this.fontSizes[this.#fontNumber]["y"]);
                this.#yOffset += Math.trunc(textHeight + this.lineSpacing);

                return this;
            }

            /**
             * Add text centered on the label, advancing the yOffset by the font height + line spacing.
             *
             * @param (string) text - The text to add
             * @param (int) size - The size to scale the font, 1-6
             *
             * @example
             *     addTextCentered("Hello world!", 1)
             */
            addTextCentered(text, size) {
                text = text || "";
                size = Math.trunc(size) || 1;

                // Width = string length * character width * char size stretch
                let textWidth = (text.length * size * this.fontSizes[this.#fontNumber]["x"]);
                let centerOffset = Math.trunc((this.#xLabel - textWidth) / 2);

                this.#addTextRaw(centerOffset, this.#yOffset, 0, this.#fontNumber, size, size, false, text);

                let textHeight = (size * this.fontSizes[this.#fontNumber]["y"]);
                this.#yOffset += Math.trunc(textHeight + this.lineSpacing);

                return this;
            }

            /**
             * Draw a line, starting at the current offset and going for length and height.
             *
             * @param (int) length - The horizontal length of the line
             * @param (int) height - The vertical height of the line
             * @param (string) drawmode - The mode to draw with, either 'black' (default), 'white', or 'xor'.
             */
            addLine(length, height, drawmode) {
                length = Math.trunc(length) || 0;
                height = Math.trunc(height) || 0;

                switch (drawmode) {
                    default:
                    case "black":
                        drawmode = "LO";
                        break;
                    case "white":
                        drawmode = "LW";
                        break;
                    case "xor":
                        drawmode = "LE";
                        break;
                }

                this.addCmd(drawmode + this.#xOffset, this.#yOffset, length, height);

                return this;
            }

            addBox(length, height, thickness) {
                length = Math.trunc(length) || 0;
                height = Math.trunc(height) || 0;
                thickness = Math.trunc(thickness) || 0;

                this.addCmd("X" + this.#xOffset, this.#yOffset, thickness, length, height);
                return this;
            }

            /**
             * Add command, concatenating given parameters with a comma.
             *
             * @param (array) parameters - The command and parameters to add, first element should be the command and the first parameter.
             *
             * @example
             * addCmd("A10", 10, 0, 1, 1, 1, "N", "Hello World!");
             */
            addCmd(...parameters) {
                this.#cmdBuffer += parameters.join(',') + "\n";
                return this;
            }

            clearCommandBuffer() {
                this.#cmdBuffer = "";
                return this;
            }

            clearOffsets() {
                this.#xOffset = 0;
                this.#yOffset = 0;
                return this;
            }

            #addTextRaw(xOffset, yOffset, rotation, font, xMultiplier, yMultiplier, reverse, data) {
                data = this.#cleanString((data || ""));
                let reverseImage = (reverse || false) ? "R" : "N";

                if (!Number.isInteger(rotation) || rotation < 0 || rotation > 3) {
                    rotation = 0;
                }

                xMultiplier = ((xMultiplier >= 1 && xMultiplier <= 6) || xMultiplier === 8) ? xMultiplier : 1;
                yMultiplier = ((yMultiplier >= 1 && yMultiplier <= 9)) ? yMultiplier : 1;

                this.addCmd("A" + xOffset, yOffset, rotation, font, xMultiplier, yMultiplier, reverseImage, "\"" + data + "\"");
            }

            #cleanString(str) {
                return str.replace(/\\/gi, "\\\\")
                    .replace(/"/gi, "\\\"")
                    .replace(/[\r\n]+/gi, " ");
            }
        }

        var printerMgr;

        document.addEventListener('readystatechange', function (event) {
            if (document.readyState === "complete") {

                const btnContainer = document.getElementById("printerlist");
                const labelForm = document.getElementById("labelForm");
                const addPrinterBtn = document.getElementById("addprinter");
                const modalElement = document.getElementById("printerOptionModal");
                printerMgr = new PrinterManager(lp2844, btnContainer, labelForm, addPrinterBtn, modalElement);

                printerMgr.printerReloadAll();
            }
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js"
        integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"
        integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13"
        crossorigin="anonymous"></script>
</body>

</html>